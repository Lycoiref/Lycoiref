{"markdownMeta":{"data":{"title":"在Nextjs中解析Markdown","description":"记录了在高版本Nextjs中解析Markdown时遇到的一些坑以及解决方案","date":"2023-11-23T00:00:00.000Z","author":"Lycoiref"},"content":"\n[[toc]]\n\n# 在 Nextjs 中解析 Markdown\n\nNext 并没有原生支持 Markdown，需要自己引入第三方库来解析，\n且在 Next 高版本中，大部分的 Markdown 解析库都存在大大小小的坑，\n本篇对笔者在 Next13（后升级为 14）中对 Markdown 进行解析时遇到的一些坑以及解决方案进行总结。\n\n本文内容：\n\n1. Markdown-it 的引入和使用\n2. Markdown-it 的代码高亮以及样式提升\n3. 高版本 Next 中的动态路由以及 SSG 预渲染支持\n\n## 0. 插件选择\n\n::: tip\n在笔者写下这篇文章时，如果你使用的 Next.js 版本 >= 13，那么笔者不推荐使用`React-Markdown`，\n建议使用 `Markdown-it` 进行替代，原因将在后文中阐明，这里只是希望看到的读者能够少走弯路。\n:::\n\n- [React-Markdown](https://github.com/remarkjs/react-markdown) 是一个基于 React 的 Markdown 解析库，相较于 Markdown-it，它更加轻量化，有着丰富的插件生态。\n\n- [Markdown-it](https://github.com/markdown-it/markdown-it) 是一个基于 JavaScript 的 Markdown 解析库，开箱即用，且支持插件扩展，原生就具备一定的 md 解析功能，更易于使用。\n\n由于 Next 使用 React 生态，因此在查询推荐的 Markdown 解析库时，笔者最初\n选择了 React-Markdown。殊不知，就是这个选择让笔者踩了一晚上坑，最终不得已\n放弃了 React-Markdown，转而使用 Markdown-it 才解决了这些问题。\n\n下面正式介绍如何在 Next 中使用 Markdown-it 进行 Markdown 解析。\n\n## 1. Markdown-it 的引入和使用\n\n### 1.0 项目背景\n\n之所以需要在 Next 中使用 Markdown，是因为笔者在开发自己的博客，显然，博客的\n内容少不了对 md 文档的解析，因此，笔者不仅需要优雅的对`Markdown`进行解析，还需要\n使用动态路由来将路由解析到对应的`Markdown`文档，奈何新版 Next 的路由与文件结构\n同样有不小的变动，且网络上资料较少，本文作为记录的同时也希望能够帮助有相同需要的\n读者少走弯路。\n\n### 1.1 安装\n\n```bash\nyarn add markdown-it\n```\n\n### 1.2 基础功能导入和使用\n\n::: tip\n本文之后的 Nextjs 版本均为 13/14，mdit 指的是 markdown-it\n:::\n\n在 Next13/14 中，我们可以在需要解析 MD 文档的`/app/pages/route/page.jsx`中引入\n`markdown-it`，在官方文档中，`mdit`的引入方式为 require，但是在 Nextjs 中，显然\n我们更倾向于使用`import`，因此我们可以使用以下方式引入`mdit`：\n\n```jsx:app/pages/route/page.jsx\nimport MarkdownIt from 'markdown-it' // 导入markdown-it\n\nexport default function Page() {\n  // 使用options创建markdown-it实例，可以在官网查看options的配置\n  const md = new MarkdownIt(options)\n  const result = md.render('# markdown-it rulezz!') // 渲染markdown文档\n\n  // 最后将渲染好的文档返回给页面即可\n  return <div dangerouslySetInnerHTML={{ __html: result }}></div>\n}\n```\n\n### 1.3 代码高亮\n\n完成上述步骤后`mdit`就已经为我们完成了基础的 md 解析功能，但是显然笔者并不满足于基础的功能，我们还\n需要对代码进行高亮，这里我们选择'highlight.js'作为代码高亮的插件（这也是`mdit`官方文档中进行代码\n高亮时使用的插件），我们可以使用以下方式引入`highlight.js`：\n\n```bash\nyarn add highlight.js\n```\n\n项目中引入\n\n```jsx\nimport MarkdownIt from 'markdown-it'\nimport hljs from 'highlight.js' // 导入highlight.js\n// 除了导入highlight.js，我们还需要导入highlight.js的样式表，这里我们选择github样式\n// 事实上highlight.js的样式表有很多种，可以在官网查看，此处不再赘述\nimport 'highlight.js/styles/github.css'\n\nexport default function Page() {\n  let md = new MarkdownIt({\n    highlight: function (str, lang) {\n      if (lang && hljs.getLanguage(lang)) {\n        try {\n          return hljs.highlight(str, { language: lang }).value\n        } catch (__) {\n          console.log(__)\n        }\n      }\n\n      return '' // use external default escaping\n    },\n    html: false, // 其他options\n    xhtmlOut: true,\n    typographer: true,\n  })\n  const result = md.render('# markdown-it rulezz!')\n\n  return <div dangerouslySetInnerHTML={{ __html: result }}></div>\n}\n```\n\n### 1.4 其他优化\n\n完成上面的操作后，我们的`md`解析页面已经初具雏形，但是显然我们还需要对`md`的样式进行优化，\n笔者这里进行的优化主要是：\n\n1. 添加了`github-markdown-css`的样式表\n2. 添加了 Anchor 插件，用于生成锚点以及跳转\n3. 添加了 Toc 插件，用于生成目录\n\n```bash\nyarn add github-markdown-css markdown-it-anchor markdown-it-toc-done-right string\n```\n\n插件的选择上读者可以根据自己的需求进行选择，这里笔者只是提供了一种可能的选择。\n\n::: tip\n使用 toc 插件需要在`.md`文件中插入[[toc]]，否则不会生成目录，这也是笔者在使用时花了\n一段时间才发现的问题。\n:::\n\n```tsx\n// 完整md解析代码\nimport 'github-markdown-css'\nimport Container from 'markdown-it-container'\nimport Anchor from 'markdown-it-anchor'\nimport Toc from 'markdown-it-toc-done-right'\nimport string from 'string'\n\nfunction legacySlugify(s) {\n  return string(s).slugify().toString()\n}\n\nexport default function Page() {\n  let md = new MarkdownIt({\n    highlight: function (str, lang) {\n      if (lang && hljs.getLanguage(lang)) {\n        try {\n          return hljs.highlight(str, { language: lang }).value\n        } catch (__) {\n          console.log(__)\n        }\n      }\n\n      return '' // use external default escaping\n    },\n    html: false, // 其他options\n    xhtmlOut: true,\n    typographer: true,\n  })\n  let md = new MarkdownIt({\n    highlight: function (str, lang) {\n      if (lang && hljs.getLanguage(lang)) {\n        try {\n          return hljs.highlight(str, { language: lang }).value\n        } catch (__) {\n          console.log(__)\n        }\n      }\n\n      return '' // use external default escaping\n    },\n    html: false,\n    xhtmlOut: true,\n    typographer: true,\n  })\n    .use(Anchor, {\n      permalink: Anchor.permalink.linkInsideHeader({\n        placement: 'before',\n        style: 'visually-hidden',\n      }),\n    })\n    .use(Toc, {\n      slugify: legacySlugify,\n      containerClass: 'toc',\n      level: [2, 3],\n    })\n    .use(Container, 'tip', {\n      render: function (tokens, idx) {\n        if (tokens[idx].nesting === 1) {\n          return '<div class=\"tip\">'\n        } else {\n          return '</div>\\n'\n        }\n      },\n    })\n  const result = md.render('# markdown-it rulezz!')\n\n  return (\n    <div\n      className=\"markdown-body\"\n      dangerouslySetInnerHTML={{ __html: result }}\n    ></div>\n  )\n}\n```\n\n之后可以建立一个额外的 css 文件，用于对`markdown-body`进行样式优化，\n进行自定义样式或者使用他人提供的样式表。\n\n如果你只需要完成对 Markdown 的解析以及渲染，那么到这里就已经完成了，\n但是如果你需要使用 Next 的动态路由以及 SSG 预渲染，那么你还需要继续阅读下面的内容。\n\n## 2. 动态路由以及 SSG 预渲染\n\n在`Next13`之后，Next 的文件结构以及动态路由的相关使用函数发生了较大的变化，\n主要是将`pages`文件夹移动到了`app`下，导致原本的`getStaticPaths`以及`getStaticProps`\n无法正常使用（报错：无法在 app 下使用 getStaticPaths）。且该问题很少有人提出，也缺少\n解决方案，笔者在解决该问题时也是花费了不少时间，最终在官方文档中找到了解决方案。\n\n### 2.1 动态路由\n\n在 Next13 之后，动态路由生成`SSG`的函数由`getStaticPaths`变为了`generateStaticParams`\n\n> 原文：\n> In the app directory, getStaticPaths is replaced with generateStaticParams.\n>\n> generateStaticParams behaves similarly to getStaticPaths, but has a simplified API for returning route parameters and\n> can be used inside layouts. The return shape of generateStaticParams is an array of segments instead of an array of\n> nested param objects or a string of resolved paths.\n\n因此，我们需要将原本的`getStaticPaths`替换为`generateStaticParams`，笔者的 markdown 文档统一存放在\n`app/markdown`文件夹下，我们在`app/pages/article/[...slug]/page.jsx`中进行动态路由的生成：\n\n首先在`markdownUtils.js`中编写获取`markdown`文件的函数：\n\n::: warning\n出于某种原因，`md`文档不能使用中文名，否则会导致错误，笔者还没有找到解决方案。\n:::\n\n```js:lib/markdownUtils.js\nimport fs from 'fs'\nimport path from 'path'\nimport matter from 'gray-matter'\n\n// Markdown files are stored in `src/markdown`.\nconst markdownDirectory = path.join(process.cwd(), 'src/markdown')\n\nexport async function getMarkdownFiles() {\n  return fs.readdirSync(markdownDirectory)\n}\n\nexport async function getMarkdownFileBySlug(slug) {\n  // use client-side fetch to get markdown file\n  let markdownFile = fs.readFileSync(\n    path.join(markdownDirectory, `${slug}.md`),\n    'utf8'\n  )\n  let { data, content } = matter(markdownFile)\n  return { data, content }\n}\n```\n\n之后在`app/pages/article/[...slug]/page.jsx`中进行动态路由的生成（遍历`markdown`文件夹）：\n\n```jsx\nexport async function generateStaticParams() {\n  let MDs = await getMarkdownFiles()\n  let slugs = []\n  // 去除非md文件\n  MDs = MDs.filter((slug) => slug.endsWith('.md'))\n  MDs.map((md) => {\n    slugs.push({\n      slug: md.replace(/\\.md$/, ''),\n    })\n  })\n  console.log('slugs')\n  console.log(slugs)\n  return slugs\n}\n\n// 在函数中使用slug\nexport default function Page({ slug }) {\n  ...\n}\n```\n\n### 2.2 总结\n\n理论上完成了上述步骤后，进行`yarn build`即可完成 SSG 的预渲染页面生成\n写完后再看其实操作并不复杂，但是在笔者的实际操作中，由于 Next 的更新后\n各版本文档散乱，缺乏汉化以及相关的实例，导致笔者在解决该问题时花费了\n不少时间，写下这篇博客也希望能帮助到有需要的读者。\n"}}
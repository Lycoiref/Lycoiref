{"markdownMeta":{"data":{"title":"在Nextjs中获取数据的正确姿势","description":"记录了如何正确在Nextjs中Fetch Data","date":"2023-11-26T00:00:00.000Z","author":"Lycoiref"},"content":"\n[[toc]]\n\n# 在 Nextjs 中获取数据的正确姿势\n\n使用Next进行SSG时，Next允许我们使用一些服务端API，如fs，\n这大大降低了我们获取数据的成本，但是在使用时，我们需要注意一些问题。\n\n## 1. Server Side Rendering\n\n因为我们SSG的最终目的是生成静态站点，因此我们的大部分组件都是需要使用\n客户端API的，而这也是Next中很坑的一点：\n\n虽然它向我们提供了服务端和客户端的API，但是这些API并不能在同一个文件中\n混用，即如果你在一个页面中使用了`useEffect`，那么这个页面就不能使用\nfs来读取文件，在以前的版本中一般使用`getStaticProps`来获取数据以及\n调用服务端API，但是在`Next13`以及之后的版本中，这个API不允许在`pages`\n路径下使用，取而代之的事`generateStaticParams`，且该API只允许返回\n动态路由的slug，因此我们并不能像之前一样在此获取数据。\n\n这时，最容易想到的解决方法就是封装一个子组件，并在子组件中使用`useEffect`\n而父组件则作为SSR的入口：\n\n```jsx\n/* eslint-disable react-refresh/only-export-components */\nimport React from 'react'\nimport ArticleCard from './Card'\nimport {\n  getMarkdownFiles,\n  getMarkdownFileBySlug,\n} from '../../../utils/markdownUtils'\n\nexport interface Article {\n  title: string\n  author: string\n  description: string\n  date: Date\n  tags: string[]\n  slug: string\n}\n\nexport default async function ArchivePage() {\n  let files = await getMarkdownFiles()\n  files = files\n    .filter((file) => file.match(/\\.md$/))\n    .map((file) => file.replace(/\\.md$/, ''))\n  const articles: Array<Article> = []\n  for (const file of files) {\n    const { data } = await getMarkdownFileBySlug(file)\n    const article = {\n      title: data.title,\n      author: data.author,\n      description: data.description,\n      date: data.date,\n      tags: data.tags || [],\n      slug: file,\n    }\n    articles.push(article)\n  }\n\n  return (\n    <div>\n      <h1>Archive</h1>\n      {articles.map((article) => (\n        <ArticleCard key={article.slug} article={article} />\n      ))}\n    </div>\n  )\n}\n\n```\n\n像这样获取数据之后，我们就会愉快的发现，至少在`yarn dev`中，一切都是\n正常的，但是当我们进行部署到生产环境时，问题出现了：\n\n![Alt text](/post2/e81f89d3f428ca443fb7d36c433da6e6.png)\n\n打开控制台，我们就能看到一片红色的报错，虽然目前笔者还不清楚是什么原因\n（欢迎大神指点），而且该页面除了有报错外其他表现均正常，但是既然出现报错\n那么就说明这种方法不是官方推荐的，因此我们需要寻找其他方法。\n\n## 2. 使用Routes Handler\n\n查阅Next文档Data Fetching部分，我们可以看到其提供了一个`Routes Handler`\n的API，该API可以在`pages/api`路径下使用，因此我们可以在该路径下创建一个\n`route.ts`文件，该文件的内容如下（只是把数据获取的逻辑移动到了该文件中）：\n\n::: tip\n注意，此处的返回值必须是`Response`，且内容为json格式，否则会报错。\n:::\n\n```ts\nimport {\n  getMarkdownFiles,\n  getMarkdownFileBySlug,\n} from '../../../../utils/markdownUtils'\n\n// export const dynamic = 'force-dynamic' // defaults to force-static\nexport async function GET() {\n  // console.log(request);\n  let files = await getMarkdownFiles()\n  files = files\n    .filter((file) => file.match(/\\.md$/))\n    .map((file) => file.replace(/\\.md$/, ''))\n  const articles = []\n  for (const file of files) {\n    const { data } = await getMarkdownFileBySlug(file)\n    const article = {\n      title: data.title,\n      author: data.author,\n      description: data.description,\n      date: data.date,\n      tags: data.tags || [],\n      slug: file,\n    }\n    articles.push(article)\n  }\n  // return {\n  //   props: {\n  //     articles,\n  //   },\n  // }\n  return Response.json({ articles })\n}\n```\n\n而在原先的`page.tsx`中，我们则使用`useEffect`来获取数据：\n\n```jsx\n/* eslint-disable react-refresh/only-export-components */\n'use client'\nimport React, { useEffect, useState } from 'react'\nimport ArticleCard from './Card'\n\nexport interface Article {\n  title: string\n  author: string\n  description: string\n  date: Date\n  tags: string[]\n  slug: string\n}\n\nexport default function ArchivePage() {\n  const [articles, setArticles] = useState<Article[]>([])\n  useEffect(() => {\n    fetch('/pages/archive/api')\n      .then((res) => res.json())\n      .then((res) => {\n        setArticles(res.articles)\n      })\n  }, [])\n\n  return (\n    <div>\n      <h1>Archive</h1>\n      {articles.map((article) => (\n        <ArticleCard key={article.slug} article={article} />\n      ))}\n    </div>\n  )\n}\n```\n\n分离出了数据获取的逻辑之后，我们就可以愉快的使用`useEffect`了，\nbuild后再部署，可以看到控制台非常干净，而且页面也正常显示。我们\n成功的解决了这个问题。\n"}}
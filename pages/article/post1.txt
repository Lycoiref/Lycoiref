1:HL["/_next/static/css/5f88011d96ca9c55.css","style",{"crossOrigin":""}]
2:HL["/_next/static/css/132aa0e288cd34ff.css","style",{"crossOrigin":""}]
0:["eXHZjPa2yv5fUry5RJa7s",[[["",{"children":["pages",{"children":["article",{"children":[["slug","post1","d"],{"children":["__PAGE__?{\"slug\":\"post1\"}",{}]}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/5f88011d96ca9c55.css","precedence":"next","crossOrigin":""}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/132aa0e288cd34ff.css","precedence":"next","crossOrigin":""}]],"$L4"]]]]
5:HL["/_next/static/css/57948b5676f14034.css","style",{"crossOrigin":""}]
6:I[8011,["185","static/chunks/app/layout-655829739f579c9c.js"],"Fireworks"]
7:I[6954,[],""]
8:I[7264,[],""]
3:[null,["$","html",null,{"lang":"zh","children":["$","body",null,{"children":[["$","$L6",null,{}],["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"initialChildNode":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children","pages","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","initialChildNode":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children","pages","children","article","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","initialChildNode":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children","pages","children","article","children",["slug","post1","d"],"children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","initialChildNode":["$L9","$La",null],"childPropSegment":"__PAGE__?{\"slug\":\"post1\"}","styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/57948b5676f14034.css","precedence":"next","crossOrigin":""}]]}],"childPropSegment":["slug","post1","d"],"styles":null}],"childPropSegment":"article","styles":null}],"childPropSegment":"pages","styles":null}]]}]}],null]
4:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Lycoiref's Blog"}],["$","meta","3",{"name":"description","content":"Generated by create next app"}]]
b:I[6930,["395","static/chunks/app/pages/article/%5Bslug%5D/page-288b37427ebf48af.js"],""]
c:T5ef4,<nav class="toc"><ol><li><a href="#在-nextjs-中解析-markdown"> 在 Nextjs 中解析 Markdown</a><ol><li><a href="#0.-插件选择"> 0. 插件选择</a></li><li><a href="#1.-markdownit-的引入和使用"> 1. Markdown-it 的引入和使用</a><ol><li><a href="#1.0-项目背景"> 1.0 项目背景</a></li><li><a href="#1.1-安装"> 1.1 安装</a></li><li><a href="#1.2-基础功能导入和使用"> 1.2 基础功能导入和使用</a></li><li><a href="#1.3-代码高亮"> 1.3 代码高亮</a></li><li><a href="#1.4-其他优化"> 1.4 其他优化</a></li></ol></li><li><a href="#2.-动态路由以及-ssg-预渲染"> 2. 动态路由以及 SSG 预渲染</a><ol><li><a href="#2.1-动态路由"> 2.1 动态路由</a></li><li><a href="#2.2-总结"> 2.2 总结</a></li></ol></li></ol></li></ol></nav><h1 id="%E5%9C%A8-nextjs-%E4%B8%AD%E8%A7%A3%E6%9E%90-markdown" tabindex="-1"><a class="header-anchor" href="#%E5%9C%A8-nextjs-%E4%B8%AD%E8%A7%A3%E6%9E%90-markdown">#</a> 在 Nextjs 中解析 Markdown</h1>
<p>Next 并没有原生支持 Markdown，需要自己引入第三方库来解析，
且在 Next 高版本中，大部分的 Markdown 解析库都存在大大小小的坑，
本篇对笔者在 Next13（后升级为 14）中对 Markdown 进行解析时遇到的一些坑以及解决方案进行总结。</p>
<p>本文内容：</p>
<ol>
<li>Markdown-it 的引入和使用</li>
<li>Markdown-it 的代码高亮以及样式提升</li>
<li>高版本 Next 中的动态路由以及 SSG 预渲染支持</li>
</ol>
<h2 id="0.-%E6%8F%92%E4%BB%B6%E9%80%89%E6%8B%A9" tabindex="-1"><a class="header-anchor" href="#0.-%E6%8F%92%E4%BB%B6%E9%80%89%E6%8B%A9">#</a> 0. 插件选择</h2>
<div class="tip"><p>在笔者写下这篇文章时，如果你使用的 Next.js 版本 &gt;= 13，那么笔者不推荐使用<code>React-Markdown</code>，
建议使用 <code>Markdown-it</code> 进行替代，原因将在后文中阐明，这里只是希望看到的读者能够少走弯路。</p>
</div>
<ul>
<li>
<p><a href="https://github.com/remarkjs/react-markdown">React-Markdown</a> 是一个基于 React 的 Markdown 解析库，相较于 Markdown-it，它更加轻量化，有着丰富的插件生态。</p>
</li>
<li>
<p><a href="https://github.com/markdown-it/markdown-it">Markdown-it</a> 是一个基于 JavaScript 的 Markdown 解析库，开箱即用，且支持插件扩展，原生就具备一定的 md 解析功能，更易于使用。</p>
</li>
</ul>
<p>由于 Next 使用 React 生态，因此在查询推荐的 Markdown 解析库时，笔者最初
选择了 React-Markdown。殊不知，就是这个选择让笔者踩了一晚上坑，最终不得已
放弃了 React-Markdown，转而使用 Markdown-it 才解决了这些问题。</p>
<p>下面正式介绍如何在 Next 中使用 Markdown-it 进行 Markdown 解析。</p>
<h2 id="1.-markdown-it-%E7%9A%84%E5%BC%95%E5%85%A5%E5%92%8C%E4%BD%BF%E7%94%A8" tabindex="-1"><a class="header-anchor" href="#1.-markdown-it-%E7%9A%84%E5%BC%95%E5%85%A5%E5%92%8C%E4%BD%BF%E7%94%A8">#</a> 1. Markdown-it 的引入和使用</h2>
<h3 id="1.0-%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF" tabindex="-1"><a class="header-anchor" href="#1.0-%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF">#</a> 1.0 项目背景</h3>
<p>之所以需要在 Next 中使用 Markdown，是因为笔者在开发自己的博客，显然，博客的
内容少不了对 md 文档的解析，因此，笔者不仅需要优雅的对<code>Markdown</code>进行解析，还需要
使用动态路由来将路由解析到对应的<code>Markdown</code>文档，奈何新版 Next 的路由与文件结构
同样有不小的变动，且网络上资料较少，本文作为记录的同时也希望能够帮助有相同需要的
读者少走弯路。</p>
<h3 id="1.1-%E5%AE%89%E8%A3%85" tabindex="-1"><a class="header-anchor" href="#1.1-%E5%AE%89%E8%A3%85">#</a> 1.1 安装</h3>
<pre><code class="language-bash">yarn add markdown-it
</code></pre>
<h3 id="1.2-%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AF%BC%E5%85%A5%E5%92%8C%E4%BD%BF%E7%94%A8" tabindex="-1"><a class="header-anchor" href="#1.2-%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%AF%BC%E5%85%A5%E5%92%8C%E4%BD%BF%E7%94%A8">#</a> 1.2 基础功能导入和使用</h3>
<div class="tip"><p>本文之后的 Nextjs 版本均为 13/14，mdit 指的是 markdown-it</p>
</div>
<p>在 Next13/14 中，我们可以在需要解析 MD 文档的<code>/app/pages/route/page.jsx</code>中引入
<code>markdown-it</code>，在官方文档中，<code>mdit</code>的引入方式为 require，但是在 Nextjs 中，显然
我们更倾向于使用<code>import</code>，因此我们可以使用以下方式引入<code>mdit</code>：</p>
<pre class="named-fence-block"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MarkdownIt</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;markdown-it&#x27;</span> <span class="hljs-comment">// 导入markdown-it</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 使用options创建markdown-it实例，可以在官网查看options的配置</span>
  <span class="hljs-keyword">const</span> md = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarkdownIt</span>(options)
  <span class="hljs-keyword">const</span> result = md.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;# markdown-it rulezz!&#x27;</span>) <span class="hljs-comment">// 渲染markdown文档</span>

  <span class="hljs-comment">// 最后将渲染好的文档返回给页面即可</span>
  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">__html:</span> <span class="hljs-attr">result</span> }}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
}
</code><div class="named-fence-filename">app/pages/route/page.jsx</div></pre>
<h3 id="1.3-%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE" tabindex="-1"><a class="header-anchor" href="#1.3-%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE">#</a> 1.3 代码高亮</h3>
<p>完成上述步骤后<code>mdit</code>就已经为我们完成了基础的 md 解析功能，但是显然笔者并不满足于基础的功能，我们还
需要对代码进行高亮，这里我们选择’highlight.js’作为代码高亮的插件（这也是<code>mdit</code>官方文档中进行代码
高亮时使用的插件），我们可以使用以下方式引入<code>highlight.js</code>：</p>
<pre><code class="language-bash">yarn add highlight.js
</code></pre>
<p>项目中引入</p>
<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MarkdownIt</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;markdown-it&#x27;</span>
<span class="hljs-keyword">import</span> hljs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;highlight.js&#x27;</span> <span class="hljs-comment">// 导入highlight.js</span>
<span class="hljs-comment">// 除了导入highlight.js，我们还需要导入highlight.js的样式表，这里我们选择github样式</span>
<span class="hljs-comment">// 事实上highlight.js的样式表有很多种，可以在官网查看，此处不再赘述</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;highlight.js/styles/github.css&#x27;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> md = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarkdownIt</span>({
    <span class="hljs-attr">highlight</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">str, lang</span>) {
      <span class="hljs-keyword">if</span> (lang &amp;&amp; hljs.<span class="hljs-title function_">getLanguage</span>(lang)) {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> hljs.<span class="hljs-title function_">highlight</span>(str, { <span class="hljs-attr">language</span>: lang }).<span class="hljs-property">value</span>
        } <span class="hljs-keyword">catch</span> (__) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(__)
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// use external default escaping</span>
    },
    <span class="hljs-attr">html</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 其他options</span>
    <span class="hljs-attr">xhtmlOut</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">typographer</span>: <span class="hljs-literal">true</span>,
  })
  <span class="hljs-keyword">const</span> result = md.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;# markdown-it rulezz!&#x27;</span>)

  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">__html:</span> <span class="hljs-attr">result</span> }}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
}
</code></pre>
<h3 id="1.4-%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96" tabindex="-1"><a class="header-anchor" href="#1.4-%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96">#</a> 1.4 其他优化</h3>
<p>完成上面的操作后，我们的<code>md</code>解析页面已经初具雏形，但是显然我们还需要对<code>md</code>的样式进行优化，
笔者这里进行的优化主要是：</p>
<ol>
<li>添加了<code>github-markdown-css</code>的样式表</li>
<li>添加了 Anchor 插件，用于生成锚点以及跳转</li>
<li>添加了 Toc 插件，用于生成目录</li>
</ol>
<pre><code class="language-bash">yarn add github-markdown-css markdown-it-anchor markdown-it-toc-done-right string
</code></pre>
<p>插件的选择上读者可以根据自己的需求进行选择，这里笔者只是提供了一种可能的选择。</p>
<div class="tip"><p>使用 toc 插件需要在<code>.md</code>文件中插入[[toc]]，否则不会生成目录，这也是笔者在使用时花了
一段时间才发现的问题。</p>
</div>
<pre><code class="language-tsx"><span class="hljs-comment">// 完整md解析代码</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;github-markdown-css&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Container</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;markdown-it-container&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Anchor</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;markdown-it-anchor&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Toc</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;markdown-it-toc-done-right&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-built_in">string</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;string&#x27;</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">legacySlugify</span>(<span class="hljs-params">s</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">string</span>(s).<span class="hljs-title function_">slugify</span>().<span class="hljs-title function_">toString</span>()
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> md = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarkdownIt</span>({
    <span class="hljs-attr">highlight</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">str, lang</span>) {
      <span class="hljs-keyword">if</span> (lang &amp;&amp; hljs.<span class="hljs-title function_">getLanguage</span>(lang)) {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> hljs.<span class="hljs-title function_">highlight</span>(str, { <span class="hljs-attr">language</span>: lang }).<span class="hljs-property">value</span>
        } <span class="hljs-keyword">catch</span> (__) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(__)
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// use external default escaping</span>
    },
    <span class="hljs-attr">html</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 其他options</span>
    <span class="hljs-attr">xhtmlOut</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">typographer</span>: <span class="hljs-literal">true</span>,
  })
  <span class="hljs-keyword">let</span> md = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarkdownIt</span>({
    <span class="hljs-attr">highlight</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">str, lang</span>) {
      <span class="hljs-keyword">if</span> (lang &amp;&amp; hljs.<span class="hljs-title function_">getLanguage</span>(lang)) {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> hljs.<span class="hljs-title function_">highlight</span>(str, { <span class="hljs-attr">language</span>: lang }).<span class="hljs-property">value</span>
        } <span class="hljs-keyword">catch</span> (__) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(__)
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// use external default escaping</span>
    },
    <span class="hljs-attr">html</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">xhtmlOut</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">typographer</span>: <span class="hljs-literal">true</span>,
  })
    .<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Anchor</span>, {
      <span class="hljs-attr">permalink</span>: <span class="hljs-title class_">Anchor</span>.<span class="hljs-property">permalink</span>.<span class="hljs-title function_">linkInsideHeader</span>({
        <span class="hljs-attr">placement</span>: <span class="hljs-string">&#x27;before&#x27;</span>,
        <span class="hljs-attr">style</span>: <span class="hljs-string">&#x27;visually-hidden&#x27;</span>,
      }),
    })
    .<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Toc</span>, {
      <span class="hljs-attr">slugify</span>: legacySlugify,
      <span class="hljs-attr">containerClass</span>: <span class="hljs-string">&#x27;toc&#x27;</span>,
      <span class="hljs-attr">level</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
    })
    .<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Container</span>, <span class="hljs-string">&#x27;tip&#x27;</span>, {
      <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">tokens, idx</span>) {
        <span class="hljs-keyword">if</span> (tokens[idx].<span class="hljs-property">nesting</span> === <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;div class=&quot;tip&quot;&gt;&#x27;</span>
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;/div&gt;\n&#x27;</span>
        }
      },
    })
  <span class="hljs-keyword">const</span> result = md.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;# markdown-it rulezz!&#x27;</span>)

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>
      <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;markdown-body&quot;</span>
      <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">__html:</span> <span class="hljs-attr">result</span> }}
    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<p>之后可以建立一个额外的 css 文件，用于对<code>markdown-body</code>进行样式优化，
进行自定义样式或者使用他人提供的样式表。</p>
<p>如果你只需要完成对 Markdown 的解析以及渲染，那么到这里就已经完成了，
但是如果你需要使用 Next 的动态路由以及 SSG 预渲染，那么你还需要继续阅读下面的内容。</p>
<h2 id="2.-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%BB%A5%E5%8F%8A-ssg-%E9%A2%84%E6%B8%B2%E6%9F%93" tabindex="-1"><a class="header-anchor" href="#2.-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%BB%A5%E5%8F%8A-ssg-%E9%A2%84%E6%B8%B2%E6%9F%93">#</a> 2. 动态路由以及 SSG 预渲染</h2>
<p>在<code>Next13</code>之后，Next 的文件结构以及动态路由的相关使用函数发生了较大的变化，
主要是将<code>pages</code>文件夹移动到了<code>app</code>下，导致原本的<code>getStaticPaths</code>以及<code>getStaticProps</code>
无法正常使用（报错：无法在 app 下使用 getStaticPaths）。且该问题很少有人提出，也缺少
解决方案，笔者在解决该问题时也是花费了不少时间，最终在官方文档中找到了解决方案。</p>
<h3 id="2.1-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1" tabindex="-1"><a class="header-anchor" href="#2.1-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1">#</a> 2.1 动态路由</h3>
<p>在 Next13 之后，动态路由生成<code>SSG</code>的函数由<code>getStaticPaths</code>变为了<code>generateStaticParams</code></p>
<blockquote>
<p>原文：
In the app directory, getStaticPaths is replaced with generateStaticParams.</p>
<p>generateStaticParams behaves similarly to getStaticPaths, but has a simplified API for returning route parameters and
can be used inside layouts. The return shape of generateStaticParams is an array of segments instead of an array of
nested param objects or a string of resolved paths.</p>
</blockquote>
<p>因此，我们需要将原本的<code>getStaticPaths</code>替换为<code>generateStaticParams</code>，笔者的 markdown 文档统一存放在
<code>app/markdown</code>文件夹下，我们在<code>app/pages/article/[...slug]/page.jsx</code>中进行动态路由的生成：</p>
<p>首先在<code>markdownUtils.js</code>中编写获取<code>markdown</code>文件的函数：</p>
<div class="warning"><p>出于某种原因，<code>md</code>文档不能使用中文名，否则会导致错误，笔者还没有找到解决方案。</p>
</div>
<pre class="named-fence-block"><code class="language-js"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>
<span class="hljs-keyword">import</span> matter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;gray-matter&#x27;</span>

<span class="hljs-comment">// Markdown files are stored in `src/markdown`.</span>
<span class="hljs-keyword">const</span> markdownDirectory = path.<span class="hljs-title function_">join</span>(process.<span class="hljs-title function_">cwd</span>(), <span class="hljs-string">&#x27;src/markdown&#x27;</span>)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getMarkdownFiles</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> fs.<span class="hljs-title function_">readdirSync</span>(markdownDirectory)
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getMarkdownFileBySlug</span>(<span class="hljs-params">slug</span>) {
  <span class="hljs-comment">// use client-side fetch to get markdown file</span>
  <span class="hljs-keyword">let</span> markdownFile = fs.<span class="hljs-title function_">readFileSync</span>(
    path.<span class="hljs-title function_">join</span>(markdownDirectory, <span class="hljs-string">`<span class="hljs-subst">${slug}</span>.md`</span>),
    <span class="hljs-string">&#x27;utf8&#x27;</span>
  )
  <span class="hljs-keyword">let</span> { data, content } = <span class="hljs-title function_">matter</span>(markdownFile)
  <span class="hljs-keyword">return</span> { data, content }
}
</code><div class="named-fence-filename">lib/markdownUtils.js</div></pre>
<p>之后在<code>app/pages/article/[...slug]/page.jsx</code>中进行动态路由的生成（遍历<code>markdown</code>文件夹）：</p>
<pre><code class="language-jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generateStaticParams</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> <span class="hljs-title class_">MDs</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getMarkdownFiles</span>()
  <span class="hljs-keyword">let</span> slugs = []
  <span class="hljs-comment">// 去除非md文件</span>
  <span class="hljs-title class_">MDs</span> = <span class="hljs-title class_">MDs</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">slug</span>) =&gt;</span> slug.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.md&#x27;</span>))
  <span class="hljs-title class_">MDs</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">md</span>) =&gt;</span> {
    slugs.<span class="hljs-title function_">push</span>({
      <span class="hljs-attr">slug</span>: md.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\.md$/</span>, <span class="hljs-string">&#x27;&#x27;</span>),
    })
  })
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;slugs&#x27;</span>)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(slugs)
  <span class="hljs-keyword">return</span> slugs
}

<span class="hljs-comment">// 在函数中使用slug</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{ slug }</span>) {
  ...
}
</code></pre>
<h3 id="2.2-%E6%80%BB%E7%BB%93" tabindex="-1"><a class="header-anchor" href="#2.2-%E6%80%BB%E7%BB%93">#</a> 2.2 总结</h3>
<p>理论上完成了上述步骤后，进行<code>yarn build</code>即可完成 SSG 的预渲染页面生成
写完后再看其实操作并不复杂，但是在笔者的实际操作中，由于 Next 的更新后
各版本文档散乱，缺乏汉化以及相关的实例，导致笔者在解决该问题时花费了
不少时间，写下这篇博客也希望能帮助到有需要的读者。</p>
a:["$","$Lb",null,{"data":{"title":"在Nextjs中解析Markdown","description":"记录了在高版本Nextjs中解析Markdown时遇到的一些坑以及解决方案","date":"$D2023-11-23T00:00:00.000Z","author":"Lycoiref"},"content":"$c"}]
9:null
